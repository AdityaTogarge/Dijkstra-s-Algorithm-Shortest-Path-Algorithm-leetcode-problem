// letcode question:1976
// Number of ways to to arive destination

/*
Example 1:
Input: n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]
Output: 4
Explanation: The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.
The four ways to get there in 7 minutes are:
- 0 ➝ 6
- 0 ➝ 4 ➝ 6
- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6
- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6
*/



class Solution {
public:
    int countPaths(int n, vector<vector<int>>& roads) {
        const int MOD = 1e9 + 7;
        unordered_map<int,list<pair<int,int>>> adj;

        for(int i=0;i<roads.size();i++)
        {
            int u=roads[i][0];
            int v=roads[i][1];
            int w=roads[i][2];

            adj[u].push_back({v,w});
            adj[v].push_back({u,w});
        }

        vector<long long> ways(n,0);
        vector<long long> dist(n,LLONG_MAX);

       // priority_queue<pair<long long,vector<long long>,greater<>> pq;
         priority_queue<
            pair<long long,int>,
            vector<pair<long long,int>>,
            greater<pair<long long,int>>
        > pq;

        dist[0] = 0;
        ways[0] = 1;
        pq.push({0,0});

        while(!pq.empty())
        {
            auto [dis,node]=pq.top();
            pq.pop();

            if(dis > dist[node])
            {
                continue;
            }

            for(auto [nei,wt] : adj[node])
            {
                long long newWt=dis+wt;
                if(newWt < dist[nei])
                {
                    dist[nei]=newWt;
                   // cout<<ways[node]<<endl;
                    ways[nei]=ways[node];
                  //  cout<<ways[nei]<<endl;
                    pq.push({newWt,nei});
                }
                else if (newWt == dist[nei]) {
                    ways[nei] = (ways[nei] + ways[node]) % MOD;
                }    


            }
        }
        return ways[n - 1] % MOD;
    }
};
